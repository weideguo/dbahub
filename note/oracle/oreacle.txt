sqlplus使用

sqlplus sys/sys_passwd@orcl as sysdba   ---登录 密码和connect_identify不是必须

help index  --查看所有命令
help command_name  --查看命令的具体解释

column col_name format a10    ---设置sqlplus中col_name列输出的长度为10
column col_name format 9999   ---设置sqlplus中col_name列输出的长度为4(即为有多少个9)
@ file_name  ---执行sql脚本；execute
----编辑缓冲区
edit afiedt.buffer   
run    ----运行缓冲区
--假脱机
spool file_name.txt   ---将以下的部分输出到文件中
	{content}
spool off	

clear screen   ----清屏

show parameter    -----显示数据库参数
show parameter listener  ----显示以中间包含listener的参数
修改参数
alter system parameter_name=p_value [scope=spfile]; --有scope则永久该变，没有则仅仅在当前实例改变
scope=memory  ---只在内存中修改，修改立即生效，重启数据库后失效
scope=spfile  ---写入spfile，需要重启后才生效
scope=both    ---同时在内存和spfile中修改，立即生效

虚拟表 dual
SELECT utl_inaddr.get_host_address FROM dual;  ----获取IP
SELECT utl_inaddr.get_host_name FROM dual;     ----获取host 名字
select sysdate from dual;    --获得当前系统时间

select dbid from v$database;	               ----DBID查询


conn sys/sys as sysdba;  --以DBA的身份登录
alter user scott account unlock;  --解锁scott

TABLESPACE(表空间)
---创建表空间  
create tablespace DEMOSPACE   
datafile 'E:\app\Administrator\oradata\orcl\DEMOSPACE_TBSPACE.dbf'   
size 1500M   
autoextend on next 5M maxsize 3000M;  
---删除表空间  
drop tablespace DEMOSPACE including contents and datafiles 
---添加数据文件
alter tablespace demospace add datafile 'E:\app\Administrator\oradata\orcl\DEMOSPACE_TBSPACE2.dbf' size 100m;
--查看表空间的大小
SELECT tablespace_name, round(bytes / (1024 * 1024), 0) total_space 
FROM dba_data_files order by tablespace_name
select tablespace_name, sum(bytes)/(1024*1024) free_space 
from dba_free_space  group by tablespace_name;
--修改数据文件大小
alter database datafile 'E:\app\Administrator\oradata\orcl\CBI_TABLESPACE.DBF' resize 2048m


----大表空间
(bigfile tablespace)  
---一个表空间只有一个数据文件
---默认创建小表空间，可以有多个数据文件 
create bigfile tablespace datafile 'path/filename' size 1000m [...]; ---创建大表空间
alter tablespace add datafile 'path/filename' size 100m;    ---小表空间添加数据文件


--非system表空间数据文件更改 
alter tablesapce tablespace_name rename datafile 'xxx/xxx/xxx' to 'yyyy/yyyy/yyy';
--system表空间(在mount模式)数据文件更改 
alter database rename file 'xxx/xxx/xxx' to 'yyyy/yyyy/yyy';


alter table table_name move tablespace_name;   ----将表转入新的表空间

create user user_name identified by "user_password"o default tablespace tablespace_name;  
alter user demo identified by demo1; --修改用户密码，也可以使用【password [user_name]】命令进行修改
alter user maclean default tablespace xyz;  ---修改默认表空间，创建用户默认使用【users】表空间

----授予用户使用表空间的权限 
alter user user_name quota unlimited on tablespace_name;  
alter user user_name quota *M on tablespace_name; 

--授权
grant create session to user_name;  
grant create table to  user_name;  
grant create tablespace to  user_name;  
grant create view to  user_name; 

权限
dba_sys_privs
dba_tab_privs
grant {object_privileges_name | system_privileges_name} to public; ---将权限授予给所有用户
系统权限(system privileges)，回收时不级联     [with admin option] 授权同时允许被授予的对象将系统权限付给其他用户
对象权限(object privileges)，回收时级联回收   [with grant option] 授权同时允许被授予的对象将对象权限付给其他用户


查看用户默认的表空间
select username,default_tablespace from dba_users;
查看表空间对应的文件
select tablespace_name,file_name from dba_data_files;

切换用户
connect system/ as sysdba;
connect xyz

删除用户及用户的所有表
drop user wdgtest cascade


--ORACLE下有三个视图
DBA_TABLES  --拥有DBA角色的用户可以查看系统中的所有表
USER_TABLES --登录数据库的当前用户拥有的所有表
ALL_TABLES  --登录数据库的当前用户有权限查看的所有表
/*
ORACLE数据字典视图的种类分别为：USER,ALL 和 DBA.
USER_*:有关用户所拥有的对象信息，即用户自己创建的对象信息
ALL_*:有关用户可以访问的对象的信息，即用户自己创建的对象的信息加上其他用户创建的对象但该用户有权访问的信息
DBA_*:有关整个数据库中对象的信息
*/
--(这里的*可以为TABLES,INDEXES,OBJECTS,USERS等。)
--1、查看所有用户
select * from dba_user;
select * from all_users;
select * from user_users;
--2、查看用户系统权限
select * from dba_sys_privs;
select * from all_sys_privs;
select * from user_sys_privs;
--3、查看用户对象权限
select * from dba_tab_privs;
select * from all_tab_privs;
select * from user_tab_privs;
--4、查看所有角色
select * from dba_roles;
--5、查看用户所拥有的角色
select * from dba_role_privs;
select * from user_role_privs;
--6、查看当前用户的缺省表空间
select username,default_tablespace from user_users;
--7、查看用户权限、角色权限
SELECT * FROM DBA_SYS_PRIVS WHERE GRANTEE='RESOURCE'

oracle账户权限设置
---外部验证
os_authent_prefix为外部账号的前缀，登陆oracle时使用账号为：前缀+系统账号
使用外部验证可以不必输入密码
1.创建操作系统用户
2.在sqlplus中创建外部验证的数据库账号
create user ops$weideguo identified externally;  --默认前缀为ops$,weideguo为操作系统中的账号
sqlplus /   ----直接登录
3.赋予账户创建会话等权限
4.修改操作系统用户的环境变量 添加修改oracle_home、path

---口令验证
使用账号和密码验证登陆
select * from sys.user$   ---查看用户
dba_users

---管理员验证
sysdba角色的密码保存在密码文件中

---更改账号密码
password user_name  --由交互提示进行修改
alter user user_name identified by new_password;  --在sysdba账户下

---安全角色
CREATE ROLE secure_role IDENTIFIED USING wdg.auth_role;   -----【wdg.auth_role】为验证的procedure名   
----使用安全角色启用角色时通过procedure验证，而不需要密码

 


数据库逻辑备份与还原
权限
DATAPUMP_EXP_FULL_DATABASE
DATAPUMP_IMP_FULL_DATABASE

--逻辑备份与恢复
1.创建目录
create directory EXP_DIR as 'D:\backup';  --在sql plus中创建目录（目录对应的位置应该存在文件夹）
grant read,write on directory EXP_DIR to weideguo;  --授权用户使用文件夹
select * from dba_directories;  --查看目录
2.数据导出  （在cmd中切换到文件夹 E:\app\Administrator\product\11.2.0\dbhome_1\BIN）
	exp system/manager@TEST file=d:\daochu.dmp full=y    --将数据库TEST完全导出，用户名system 密码manager，导出到d:\
	exp file=d:\daochu.dmp 
	expdp weideguo/weideguo@orcl DIRECTORY=EXP_DIR DUMPFILE=wdg.dmp LOGFILE=wdg.log SCHEMAS=weideguo JOB_NAME=exp_weideugo_schema
	expdp USERID='sys/carnation@pdborcl as sysdba' schemas=cbi_mo directory=EXP_DIR dumpfile=cbi_mo.dmp logfile=cbi_mo.log version=11.2.0.1.0  job_name=expdp_job
3.导入
	imp wdgtest/wdgtest@orcl fromuser=weideguo touser=wdgtest file=d:\back.dmp
	impdp schemas=cbi_mo directory=EXP_DIR  dumpfile=cbi_mo.dmp logfile=cbi_mo.log version=11.2.0.1.0 job_name=impdp_job
	impdp remap_schema=cbi_mo:wdgtest directory=EXP_DIR remap_tablespace=PDBORCL_CBI:WDGTEST_SPACE dumpfile=cbi_mo.dmp logfile=cbi_mo.log version=11.2.0.1.0 job_name=impdp_job         --将从用户cbi_mo导出的数据导入用户wdgtest

	impdp system/Carnation2015 directory=data_pump_dir dumpfile=test.dmp sqlfile=test.sql  ----使用sqlfile参数将原有导出的dmp文件导成sql文件
	impdp  attach=job_name    ---查看导入为job_name的导入运行状况

transportable tablespace (可移植表空间)
---导出元数据，由表空间文件导入到另外的数据库
---使用impdp/expdp

SQLLDR(sql loader)
两种加载数据的模式： ----执行sqlldr命令时指定【direct】参数为true或false，选择为直接或传统加入
1. conventional path: 生成普通的insert命令对表进行插入操作。
2. direct path: 直接对数据文件进行修改，是将被插入的表锁住，目的是提高加载的速度。
---将文件的数据(如csv文件)导入到数据库中

DBV(DB Verify)   
---执行物理数据结构的完整性检查
dbv file=/u01/app/oracle/oradata/orcl/users01.dbf [blocksize=8192]
	
                   
oracle体系结构
实例(instance) = SGA+进程  
oracle服务器   = 数据库+实例

oracle逻辑组成
dba_segment
dba_extents
block(块)    -----最小读取单位
extent(区)   -----最小分配单位 由固定多个块组成 
segment(段)  -----由多个区组成，对应数据库中的对象，如一个表对应一个段



SGA(System Global Area)系统全局区    	---【sga_target】 初始分配，【sga_max_size】
	共享池 (shared pool) 				---【shared_pool_size】 缓存最近执行的SQL语句以及数据字典。库高速缓存(library cache)、数据字典缓冲区(dictionary cache)、行执行消息缓冲区(Buffers for parallel execution messages)，以及用于系统控制的各种内存结构。
	高速缓冲区(buffer cache)   			---【db_cache_size】 脏缓冲区(dirty buffer)、自由缓冲区(free buffer)[缓冲内容与磁盘文件内容一致]、忙缓冲区(pinned buffer)[服务器进程正在访问的缓冲区]。
	重做日志缓冲区(redo log buffer)     ---【log_buffer】Oracle在执行任何DML和DDL操作改变数据之前，都会将恢复所需要的信息，先写入重做日志缓冲区，然后再写入数据库高速缓冲区。
	java池(java pool)   				---【java_pool_size】
	大池(large pool)    				---【large_pool_size】 供一次性大量的内存分配使用
	流池(stream pool)   				---【streams_pool_size】

查看sga【show parameter sga】，修改sga大小【alter system sga_max_size=1024m scope=spfile; (使用both为同时在线更改，使用scope需要重新启动后才生效)】
v$memory_dynamic_components   ---查看各个组件内存占用大小
V$SGA_DYNAMIC_COMPONENTS  ---查看SGA的动态内存分配
【memory_target】=SGA+PGA  --分配给SGA和PGA的内存值，不能超过【MEMORY_MAX_TARGET】。

自动内存管理(AMM Automatic Memory Management): memory_target=非0。LOCK_SGA ＝ true ，则 AMM 是不可用的。
自动共享内存管理(ASMM Automatic Shared Memory Management): memory_target=0 、sga_target=非0 
手工共享内存管理: memory_target=0 、sga_target=0，指定 share_pool_size 、db_cache_size 等 sga 参数
自动 PGA 管理: memory_target=0 、workarea_size_policy=auto 、PGA_AGGREGATE_TARGET=非0
手动 PGA 管理: memory_target=0 、workarea_size_policy=manal ， 指定SORT_AREA_SIZE 等 PGA 参数。一般不使用手动管理PGA

buffer cache中的buffer根据不同的状态可以分为以下4种类型：
free buffer/unused buffer：buffer cache初始化时或者在执行alter system flush buffer_cache以后的buffer,该buffer中没有存放任何内容。
clean buffer：server process从数据文件中读入的block且还没有被其他进程所修改或者又dbwr将dirt buffer刚刚写入到数据文件中的buffer,该buffer中的内容与数据文件中的block一致。
pinned buffer：当前的buffer被某个进程正在读取或者正在修改时。
dirt buffer：该buffer的内容与数据文件中block的内容不一致。

alter system flush shared_pool;     ----清空共享池
alter system flush buffer_cache;	----清空高速缓冲区


	
数据库文件(data file)
--dba_data_files
--数据文件依赖与表空间存在，保存数据库中数据的文件

alter system dump datafile file_num block block_id ;   ---file_num可以由dba_data_files数据字典产看
alter system dump datafile file_num block min min_block_id max max_block_id; 

	
控制文件(controlfile)
v$controlfile
v$parameter
v$controlfile_record_section
控制文件中记载了数据文件、重做日志名称和位置、日志序列号、检查点和日志历史信息，以及RMAN备份信息
包含：可变部分、不可变部分
----它记录了数据库的名字、数据文件的位置等信息
---用于记录和维护数据库结构（数据库名、数据文件的名称和路径、联机重做日志文件的名称和路径、备份信息等，包括rman的备份信息）
select value from v$parameter where name='control_files';   ----查询控制文件的路径

--备份控制文件
alter database backup controlfile to trace as '/home/oracle/ctl';
创建重建控制文件脚本
cat ctl | grep -v ^- | grep -v ^$ > c.sql   ----去空行及注释，备份控制文件创建脚本
查看控制文件内容
strings controlfile_name   ---查看控制文件，控制文件以二进制存储，不能直接查看，strings可以用于查看二进制文件
sqlplus中：
oradebug setmypid
oradebug dump controlfile 3  --3是dump level，在user_dump_dest参数指定的路径查看dump的内容

http://blog.csdn.net/tianlesoftware/article/details/6525628


联机重做日志文件(online redo log)
---v$log/v$logfile
---保存对数据库的变更操作
---联机重做日志循环写入；把重做日志文件保存，称为归档，得到归档日志
alter system dump logfile logfile_name;    ----导出联机重做日志文件

日志组有四种状态：unused, current ,active ,inactive;
unused:表明该日志组从来没有被使用过。
current:是oracle当前正在使用的日志组，即后台进程LGWR正在写的日志组。
active:当发生日志切换的时候，状态为current的日志组就会变成active状态，表明记录在这个日志组的事务提交所造成的数据块改变，还没有完全从database buffer cache 写入到data file中。当数据库处于archivelog mode时，ARCn就会归档这个日志组。所以处在这个状态的日志组是不允许被覆盖的。崩溃恢复需要该状态，可用于块恢复，可能归档也可能未归档。
inactive:处于这个状态的日志组，表明记录在这个日志组的事务提交所造成的数据块的改变，已经完全从database buffer cache写入到data file中了，实例恢复不再需要这个状态的日志组了，所以这个日志组是可以被覆盖的。

---表级日志设置
alter table t_target {logging|nologging|force logging};
logging     	----default 记录日志信息到联机重做日志文件，临时表空间将不记录日志到联机重做日志文件
nologging	 	----不记录
force logging	----数据库的操作都记录到到联机重做日志文件，临时表空间或临时回滚段除外，忽略类似NOLOGGING之类的指定参数   取消NO FORCE LOGGING;

---查看日志模式
select log_mode,force_logging from v$database;   
select tablespace_name,logging,force_logging from dba_tablespaces;

alter system switch logfile; --切换当前日志组，如果处于归档模式则进行归档


alter database [db_name] add logfile [group 4]('logfile_path') size 50M;  --添加日志组
alter database [db_name] add logfile member ('logfile_path') to group 4;  ---为已经存在的日志组添加成员，同组成员互为镜像
alter database [db_name] drop group 4;  --删除日志组，但不删除在操作系统中的文件
alter database [db_name] drop logfile member 'logfile_path';  --删除日志组成员
日志文件重定位
alter database rename file  'xxxx' to 'yyyy';  --需要在在模式

---清空日志组
alter database clear logfile group 4; 
ALTER DATABASE CLEAR UNARCHIVED LOGFILE GROUP 5;  ----清空避免归档

---分析归档日志
1.设置数据字典导出路径
alter system set utl_file_dir='/home/oracle' scope=spfile;
execute dbms_logmnr_d.build(dictionary_filename=>'logminer_dict.ora',dictionary_location=>'/home/orcle');
2.增加需要分析的重做日志文件
execute dbms_logmnr.add_logfile(LogFileName='/u01/app/oracle/oradata/orcl/redo01.log',options=>dbms_logmnr.new);
3.执行日志加载
使用数据字典
execute dbms_logmnr.start_logmnr(DictFileName=>'/home/orcle/logmnr_dict.ora');
使用在线字典
execute dbms_logmnr.start_logmnr(Options=>dbms_logmnr.DICT_FROM_ONLINE_CATALOG);
4.查看日志
select sql_redo from v$logmnr_contents where table_name='table_name';
5.卸载日志
execute dbms_logmnr.end_logmnr



归档日志(archive log)   
----recover命令使用归档日志，联机重做日志

alter database archivelog;  --在mount模式启用归档，noarchivelog为非归档

archive log list  --查看归档状态

alter system archive log current;   ---归档当前的联机重做日志文件
alter system switch logfile;  		--强制更换当前归档日志组,在自动归档模式即同时将当前的日志组进行归档


修改归档路径

alter system set log_archive_dest_1='location=path [mandatory]' scope=spfile;  --mandatory指定这个位置的归档必须成功。默认为optional，即在多路归档下不强制要求都成功；如果都为optional，则至少一路归档成功。
alter system set log_archive_dest_2='service=standby_db' scope=spfile;   ---设置归档到另外的数据库。【standby_db】为tnsnames.ora文件中指定的connect identifier


log_archive_start为true则为自动归档，flase则不为自动归档，可以使用
alter system set log_archive_start=true scope=spfile  ---mount模式自动归档设置
alter system archive log start; --设置为自动归档，stop为非自动归档，无须重新启动实例，即可立即启用自动归档功

手工归档
ALTER SYSTEM ARCHIVE LOG ALL;
alter system archive log current；

SELECT * FROM v$loghist;    ---查看日志历史信息
SELECT destination FROM v$archive_dest;   ---查看归档日志路径
SELECT name,log_mode FROM v$database;   ---归档状态
SELECT * FROM v$archive_processes;   ---归档进程



权限管理
在sqlnet.ora中($oracle_home/network/admin)
SQLNET.AUTHENTICATION_SERVICES= (NTS)   --使用操作系统验证，即可以不输出密码也可以sysdba登陆
SQLNET.AUTHENTICATION_SERVICES= none    --取消使用操作系统验证

修改sqlplus默认设置文件
文件路径$oracle_name/sqlplus/admin/glogin.sql
set sqlprompt "_user '@' _connect_identifier>"   ----修改sqlplus的提示符

监听文件
$oracle_home/NETWORK/ADMIN/listener.ora     --用于设置监听监听地址及端口供其他连接使用
$oracle_home/NETWORK/ADMIN/tnsnamers.ora    --用于设置connect_identifier以实现本地连接其他服务器
tnsping connect_identifier   ---测试tnsnames.ora中设置的connnect_identifier是否正确

show parameter name;  --查询服务名	 
alter system set service_names='orcl,ocp' scope=spfile;  --修改服务名，多个服务名使用【，】分开，可用于tnsnames.ora中的设置

alter system set local_listener=t1 scope=spfile;         ---如果监听非1521端口，必须设置，t1为tnsnames.ora中设置的服务名
启动非默认listener监听器
在lsnrctl中 	
	set curr listener_name;   ---设置当前的监听器名，监听器在listener.ora中设置
	start   ---启动当前监听器

lsnrctl start   ----启动监听默认的listener监听
ps -ef|grep LOCAL=NO  产看是否有远程连接,同时依次杀进程	

【remote_listerner】   ----设置后使用远端的listener处理会话？？？

修改数据库监听程序
/配置和移植工具/Net Manager/Oracle Net配置/本地/监听程序/LISTENER   ---windows下监听设置
$ORACLE_HOME/network/admin/listener.ora   ---修改配置文件设置监听
动态监听
LISTENER_NAME=(DESCRIPTION_LIST...)
使用TCP/IP协议中的端口，端口号的范围从0到65535
使用IPC
(Inter-Process Communication)进程间通信

静态监听
LISTENER_NAME=(SID_LIST...)
使用动态链接库文件


初始化参数文件
$oracle_home/dbs/init.ora

启动次序spfile优先于pfile
show parameter spfile;  ---查看使用的服务器参数文件

--参数文件pfile（parameter file）对应路径
--spfile（server parameter file） 9i之后使用  服务器参数文件 可由pfile创建
--利用文件对数据库和实例进行配置
SELECT NAME, VALUE, DISPLAY_VALUE FROM V$PARAMETER WHERE NAME ='spfile';    --查看初始化参数文件位置

服务器参数文件  
v$spparamater   ---isspecified确定是否启用
v$parameter   ---show parameter
spfile(server parameter file)由pfile(对应为$oracle_home/dbs/init.ora文件)创建   【spfile】参数中指定路径
spfile可以在线更改，pfile需要重启才起作用

create spfile[="path_name/file_name"] from pfile[="path_name/file_name"];  ---由pfile创建spfile
create pfile[="path_name/file_name"] from spfile[="path_name/file_name"];  ---由spfile创建pfile

概要文件 profile  (概要文件存储在数据字典里?)用户的资源与口令的限制
数据字典：
dba_profiles 
dba_user
用户的口令限制和资源使用,资源参数用于限制资源的使用，密码参数设置与密码有关的安全策略   
alter profile profile_name limit parameter_name parameter_value;	---修改概要概要文件
create profile profile_name
		item_name1 item_value1
		item_name2 item_value2;              ---创建概要文件
alter user user_name profile profile_name;   ---更改用户的概要文件


密码文件
授予SYSDBA 或者SYSOPER角色的用户口令保存于外部文件[$ORACLE_HOME/dbs/orapworcl]
CONNECT username / password[ @db_alias] AS [ SYSOPER | SYSDBA ];  
select * from v$pwfile_users   --使用口令文件进行身份验证的用户列表，即被授予sysdba角色的用户
remote_login_passwordfile    ---设置是否允许远程登录使用口令文件进行身份验证【none | shared | exclusive】
ldap_directory_sysauth       ---{yes|no},允许或禁止对sysdba或sysoper权限的目录授权

orapwd file=sys_password_filename passowd=sys_password     ---创建密码文件

告警文件、追踪文件
---$ORACLE_BASE/diag/diag/rdbms/orcl/orcl/alert    ---log.xml  
---$ORACLE_BASE/diag/diag/rdbms/orcl/orcl/trace    ---alert_orcl.log  【BACKGROUND_DUMP_DEST】指定
---【diagnostic_dest】参数为alert日志的根目录  默认为$ORACLE_BASE/diag
告警信息
DBA_OUTSTANDING_ALERTS    
DBA_ALERT_HISTORY    ---告警被清除后转到这个数据字典

ADR(Automatic Diagnostic Repository)    ---存放数据库诊断日志、跟踪文件的目录
v$diag_info

Oracle跟踪文件分为三种类型
1.后台报警日志文件
    记录数据库在启动、关闭和运行期间后台进程的活动情况,如表空间创建、回滚段创建、某些alter命令、日志切换、错误消息等。在数据库出现故障时，应首先查看该文件，但文件中的信息与任何错误状态没有必然的联系。
2.DBWR、LGWR、SMON等后台进程创建的后台跟踪文件
    后台跟踪文件根据后台进程运行情况产生，保存在【BACKGROUND_DUMP_DEST】。
3.由连接到Oracle的用户进程(Server Processes)生成的用户跟踪文件
    这些文件仅在用户会话期间遇到错误时产生。此外，用户可以通过执行oracle跟踪事件来生成该类文件，保存在【USER_DUMP_DEST】。

	

PGA(Programn Global Area)   --【pga_aggregate_target】
	每个服务进程私有的内存区域	
	
UGA
User Global Area 用户全局区
---这个内存区与特定的会话相关联，保存会话的状态。
--用共享服务器(shared)，UGA 就在SGA 中分配；
--如果使用专用服务器(dedicated)，UGA就会在PGA中。	


db_cache_size指定默认block的db_nK_cache_size的大小
---即如果db_block_size指定为8k，db_8k_cacahe_size不能再指定


进程
	SMON  系统监视器(System Monitor)
	PMON  进程监视器(Process Monitor) 当取消当前的事务，或释放进程占用的锁以及释放其它资源之后，PMON进程清空那些失败的进程。
	DBWR  数据库书写器(Database Write)
	LGWR  日志书写器(Log Write) 日志写入进程负责将重做日志缓冲区的日志条目写入磁盘上的联机日志文件
	CKPT  进程是检查点(Checkpoint) 检查点进程的作用是执行一个"检查点(checkpoint)"，同步数据库的所有数据文件、控制文件和重做日志文件。在执行一个检查点之后，数据库处于一个完整状态。
	
	MMON  定期将统计信息从内存写到磁盘
	MMAN  Memory Management 
	ARCn  写归档日志
	ASMB  ASM实例中与前台程序连接，与ASM实例通信


	用户进程
	数据库进程
		服务器进程
		后台进程 v$bgprocess

客户进程与服务进程一一对应，为专有(dedicated)服务器连接    
多个客户进程对应一个服务器进程，为共享(shared)服务器连接    
---【shared_servers】为0则表示数据库没有启动共享服务模式；指定了当instance 启动的时候 shared server process 启动的数量。
---【shared_server_sesions】指定了总共允许的的shared server session 的数量。
---【dispatcher】设置类似【(PROTOCOL=TCP)(DISPATCHERS=3)】，在服务端启用共享连接，同时专有连接也生效。 v$dispatcher 查看共享连接的状态
----由连接时选的connect_identifier的配置(tnsnames.ora文件中设置)确定连接的方式。

---【processes】指定最大进程数，v$process查看当前进程
---【sessions】指定最大会话数，v$session查看当前会话


CHECKPOINT
检查点  
---checkpoint值为发出checkpoint时的scn(system change number)的值。
---【fast_start_mttr_target】的值为实例恢复的最大时间，系统计算这个时间可以保留的脏块，达到脏块容量则更改检查点
---checkpoint事件由checkpoint进程（LGWR/CKPT进程）发出，当checkpoint事件发生时DBWn会将脏块写入到磁盘中，同时数据文件和控制文件的文件头也会被更新以记录checkpoint信息，数据文件对应的scn记录在控制文件
alter system checkpoint;  --手动执行checkpoint，一般系统自动执行

SCN(System Change Number)

联机日志文件、数据文件、控制文件同时记录scn
orcle先更改重做日志，再在内存中更改信息，在达到一定条件再将脏块写入磁盘，发出检查点才会将SCN信息写入到控制文件和数据文件头部。


触发checkpoint条件
1.当发生日志组切换的时候 
2.当符合LOG_CHECKPOINT_TIMEOUT，LOG_CHECKPOINT_INTERVAL，fast_start_io_target，fast_start_mttr_target参数设置的时候 
3.当运行ALTER SYSTEM SWITCH LOGFILE的时候 
4.当运行ALTER SYSTEM CHECKPOINT的时候 
5.当运行alter tablespace tablespace_name begin backup，end backup的时候 
6.当运行alter tablespace,datafile offline的时候
7.Shutdown abort外的关库命令
8.运行alter tablespace tablespace_name read only时

【fast_start_mttr_target】     -----实例恢复时间，即为发出checkpoint后，由于数据库异常关闭，充新启动实例之后需要恢复checkpoint之后的操作所需要的时间
-----【fast_start_mttr_target】为0时，禁用MTTR advisor
-----【LOG_CHECKPOINT_INTERVAL】为0，禁用automatic checkpoint tuning 


select file#,checkpoint_change# from v$datafile_header;  ----查看各个文件的检查点
select checkpoint_change# from v$database;   			---查看数据库的检查点

SMON在启动时依照检查点和SCN恢复实例

select a.name,a.checkpoint_change# start_scn,b.checkpoint_change# last_scn from v$datafile_header a,v$datafile b where a.file#=b.file#;    
----v$datafile			是记录在控制文件中各个文件的SCN和对应信息
----V$datafile_header	是记录在数据文件头中对应的文件信息


进程会话相关视图	
v$session
v$process
v$mystat	
---查看连接的信息
select sid,serial#,username,program,machine,client_info from v$session
where username is not null
order by username,program,machine; 
---关闭会话
select saddr,sid,serial#,paddr,username,status from v$session 
alter system kill session 'sid,serial#' ;

----根据sid查询sql语句的spid，由spid杀死进程即可结束会话
select b.spid,a.sid,a.serial#,a.machine from v$session a,v$process b where a.paddr =b.addr  and a.sid = '&sid';
----输入SID号查sql语句
select sql_text from v$sqlarea where (hash_value,address)=(select sql_hash_value,sql_address from v$session where sid=&sid);
----由spid查看sid,serial#  使用【top -u oracle】系统命令查看oralce用户的进程
select sid,serial# from v$session where paddr in (select ADDR from v$process where spid=&spid);
----杀会话
alter system kill session 'sid,serial#';

linux中查看内存占用情况
top -u process_name 
ps aux 查看所有占用资源
----ps aux |head -1 ;ps aux |sort -rn +2 |head -10   ###修改【sort -rn +x】指定由第x+1列排序

---找到当前所有session IO信息
select ses.username,ses.sid,ses.status,
   max(decode(sta.name,'session logical reads',sest.value)) as "LOG IO",
   max(decode(sta.name,'physical reads',sest.value)) as "PHY IO",
   round(max(decode(sta.name,'session logical reads',sest.value))
        /(3600*24*(sysdate-ses.logon_time)),2) as "LOG IO/S",
   round(max(decode(sta.name,'physical reads',sest.value))
        /(3600*24*(sysdate-ses.logon_time)),2) as "PHY IO/S",
        trunc(60*24*(sysdate-ses.logon_time)) as "Minutes"
        from v$session ses,v$sesstat sest,v$statname sta
        where ses.sid=sest.sid and sest.statistic#=sta.statistic#
           and sta.name in ('session logical reads','physical reads')
           and ses.username is not null
   group by ses.username,ses.sid,ses.status,ses.logon_time
   order by 1,2;
---然后通过找到的sid，可以查看该session正在执行什么sql，以及sql的执行计划：
select sql_fulltext from v$sqlarea
  where (hash_value,address) =
         (select decode(sql_hash_value,0,prev_hash_value,sql_hash_value) as hash_value,
                decode(sql_hash_value,0,prev_sql_addr,sql_address) as sql_addr
                 from v$session where sid=&sid);
SELECT operation, options, object_name, cost FROM v$sql_plan
   WHERE (hash_value,address)=
  (select decode(sql_hash_value,0,prev_hash_value,sql_hash_value) as hash_value,
       decode(sql_hash_value,0,prev_sql_addr,sql_address) as sql_addr
        from v$session where sid=&sid);



事务(transaction)

savepoint [a];    ---设置存储点
rollback [to savepoint a];   ----回滚到存储点。提交事务使用【commit】


DDL (Data Definition Language)  	create/alter/drop
DML (Data Manipulation Language)  	select/update/insert/delete
DCL (Data Control Language)  		grant/rollback/commit


oracle 隔离级别
set transaction isolation level { read uncommited | READ COMMITTED | REPEATABLE READ | SERIALIZABLE }
READ UNCOMMITTED   --幻想读、不可重复读和脏读都允许。
READ COMMITTED 	   --允许幻想读、不可重复读，不允许脏读
REPEATABLE READ    --允许幻想读，不允许不可重复读和脏读
SERIALIZABLE       
--幻想读、不可重复读和脏读都不允许 
--读加共享锁，写加排他锁，读写互斥，使用的悲观锁的理论


1.幻想读：事务T1读取一条指定where条件的语句，返回结果集。此时事务T2插入一行新记录，恰好满足T1的where条件。然后T1使用相同的条件再次查询，结果集中可以看到T2插入的记录，这条新纪录就是幻想读。
2.不可重复读取：事务T1读取一行记录，紧接着事务T2修改了T1刚刚读取的记录，然后T1再次查询，发现与第一次读取的记录不同，这称为不可重复读。
3.脏读：事务T1更新了一行记录，还未提交所做的修改，这个T2读取了更新后的数据，然后T1执行回滚操作，取消刚才的修改，所以T2所读取的行就无效，也就是脏数据。

/*查看ORACLE当前SESSION的事务隔离级别*/
SELECT s.sid, s.serial#,
   CASE BITAND(t.flag, POWER(2, 28))
      WHEN 0 THEN 'READ COMMITTED'
      ELSE 'SERIALIZABLE'
   END AS isolation_level
FROM v$transaction t 
JOIN v$session s ON t.addr = s.taddr
AND s.sid = sys_context('USERENV', 'SID');


MVCC(Multi-Version Concurrency Control) 多版本并发控制
read没有阻塞write, 使用MVCC的技术解决了write/read相互阻塞的问题

把没有开启MVCC特性的，使用read/write相互阻塞的锁机制来保证数据一致性的这种锁叫悲观锁，
而对开启MVCC机制的锁，叫做乐观锁，大多基于数据版本(Version)记录机制实现

MVCC的一种简单实现是基于CAS(Compare-and-swap)思想的有条件更新(Conditional Update)


数据库模式
	nomount	
		startup nomount    ---关闭时进入nomount
		读初始化参数文件，启动实例  
	mount
		startup mount			---关闭时进入mount
		alter database mount;   ---nomount时进入
		oracle按照初始化参数文件的control_file打开控制文件。
		控制文件记录数据的物理结构等数据库信息，如数据文件和日志文件信息。
	open
		alter database open;     ---nomount、mount时进入
		oracle依据控制文件所记录的数据文件和重做日志信息，打开数据文件和重做日志文件

select open_mode from v$database;   ----查看数据库的启动状态		
	
open阶段有两个recovery
Media Recovery   基于online redo log
Cache Recovery	 依赖bootstrap$等数据字典
	
--启动数据库
startup nomount  --创建并启动数据实例
startup mount
startup [open]
startup force     --相当与执行shutdown abort后再startup open
startup restrict  --只能DBA使用，限制运行的实例只能在本地管理
	--受限状态接换enable/disable
	alter system enable restricted session;
startup pfile='path\file_name'     --指定数据库文本初始化参数文件的位置与名称
---关闭数据库
SHUTDOWN NORMAL        不允许新的连接、等待会话结束、等待事务结束、做一个检查点并关闭数据文件。启动时不需要实例恢复。
SHUTDOWN TRANSACTIONAL 不允许新的连接、不等待会话结束、等待事务结束、做一个检查点并关闭数据文件。启动时不需要实例恢复。
SHUTDOWN IMMEDIATE     不允许新的连接、不等待会话结束、不等待事务结束、做一个检查点并关闭数据文件。没有结束的事务是自动rollback的。启动时不需要实例恢复。 
SHUTDOWN ABORT         不允许新的连接、不等待会话结束、不等待事务结束、不做检查点且没有关闭数据文件。启动时自动进行实例恢复。
--数据库状态转换 由nomount状态开始
alter database mountout;
alter databse open;
alter database open read write;  --可读写方式打开
alter database open read only;   --只读方式打开
--静默状态 只能允许DBA用户在数据库中执行事务操作
alter system quiesce restricted;
alter system unquiesce;
--挂起状态 数据库文件和控制文件的I/O都被暂停
alter system suspend; --挂起
alter systen resume;  --退出挂起
select database_status from v$instance;  --查询状态 active为正常状态 suspend为挂起状态



ORACLE对象

查询创建语句
SET LONG 1000;   ---长类型显示字节数
select dbms_metadata.get_ddl('TABLE','table_name') from dual;     --查看创建表语句             
select dbms_metadata.get_ddl('TABLESPACE',a.tablespace_name) from dba_tablespaces a;  --查看创建表空间语句             
SELECT * FROM ALL_SOURCE;  --查看存储过程创建语句

说明
comment on column table_name.column_name is 'xxxxxx';
comment on table table_name is 'xxxx';
select　* from user_tab_comments;  --使用数据字典查询说明　 user_col_comments为字段的说明
				 

表空间
system  --sys、system等用户的表空间
sysaux  --system的辅助表空，system auxiliary
undotbs1   --回滚段表空间（撤销表空间）。事务在未提交前更改的记录保存于此。
		   --参数【UNDO_RETENTION】设置保留时间，如果回滚段表空间大小固定，则参数不启作用。
		   --Auto Undo Management（UNDO自动管理）。【undo_management】为【auto】则启用自动撤销管理；【manual】将不启用回滚段。
ALTER DATABASE UNDOTBS01 RETENTION GUARANTEE;     ---保证数据库中的撤销保留。当表空间使用满，则不能再执行DML。
ALTER DATABASE UNDOTBS01 RETENTION NOGUARANTEE;   ---关闭撤销信息的保证保留	   
select tablespace_name,retention from dba_tablespaces;   --查看保留状态
select b.tablespace_name,AUTOEXTENSIBLE,RETENTION  from dba_tablespaces a,dba_data_files b where a.TABLESPACE_NAME=b.TABLESPACE_NAME and b.TABLESPACE_NAME='UNDOTBS1';   ----查看表空间的guarantee状态

database_properties      -----保存数据库全局默认表空间的信息
alter database default tablespace tablespace_name;   ----修改系统默认表空间


数据字典
本地管理	(9i后为缺省)表空间的存储管理信息保存在表空间的数据文件的头部
字典管理	由数据字典管理，数据字典存储在system表空间

HWM(high water mark)
--高水位线	
truncate  回收高水位线	
delete    不回收高水位线

alter table table_name shrink cascade;   ----收缩高水位线(hwm high water mark)；tablespace也可以收缩


Oracle表分类：普通堆表，索引组织表，簇表，临时表，外部表，分区表

IOTs Index-Organized Tables
索引组织表数据是按主键有序的存储在B树索引结构中。与一般B树索引不同的的是，在IOT中每个叶结点即有每行的主键列值，又有那些非主键列值。
create table indexTable(
	ID varchar2 ( 10 ),
	NAME varchar2 ( 20 ),
	constraint pk_id primary key ( ID )
)
organization index ;

--外部表
--数据库中只保存表的定义，数据以文件形式保存在数据库之外
--两种访问驱动
--oracle_loader 只可将外部源数据加载到数据库中
--oracle_datapump 可以加载数据，也可从数据库中导出到外部源文件
--创建外部表
create table ext_emp   --创建表 
(
	emp_id number(4),
	ename varchar(10),
	job varchar(10),
	mgr_id number(4),
	hiredate varchar(20),
	salary number(8,2),
	dept_id number(2)
)
organization external     --说明建立外部表
(   
	type oracle_loader    --指定访问驱动，可以为oracle_loader和oracle_datapump
	default directory datadir  --指定默认目录对象
	access parameters(    --设置数据源文件与表中行之间的映射关系
		records delimited by newline  --设置记录的分隔符
		badfile baddir:'empxt%a_%p.bad' --不必须 --设置坏文件的存放目录和文件名
		logfile logdir:'empxt%a_%p.log' --不必须 --设置日志文件的存放目录和文件名
		fields terminated by ','  --设置文件中字段分隔符
		missing field values are null   --不必须  --设置无值字段处理,如果有这条语句，需要放在设置分隔符语句后？
		(                               --必须与创建时的顺序一致，并且不能漏
			emp_id,ename,job,mgr_id,    
			hiredate,salary,dept_id
		)
	)
	location('example2.dat')  --数据源文件，多个使用','分隔
) 
parallel  					--不必须  --支持对外部数据源文件的并行查询
reject limit unlimited;  	--不必须  --设置多少行转换失败时返回oracle错误，默认为0. 


cluster
--簇  一个簇由共享相同数据块的一组表组成，这些表共享某些公共列。
--如果经常要访问这些列，能够给减少硬盘I/O

分区表  
---将一张表划分为多个部分
select * from table_name partition (p1);   ---查询p1分区的值

----创建分区表
create table table_name(
......
)
partition by (column_name)
(
......
);

---分割一个分区
ALTER TABLE  rang_test  SPLIT PARTITION P6 
AT (TO_DATE('2015-09-01 00:00:00', 'SYYYY-MM-DD HH24:MI:SS',  'NLS_CALENDAR=GREGORIAN')) 
INTO (PARTITION P3 tablespace tbs_wdg,PARTITION P6) ;

----交换分区
----将table1分区p1的内容指定为table2的内容，并不涉及数据修改或复制。
alter table table1 exchange partition p1 with table table2;

删除一个分区
alter  table orders  truncate partition p1 [update [global] index];
	

临时表
create global temporary table tmp(...) on commit {delete|preserve} rows;

ON COMMIT DELETE ROWS   ----当事务提交后，临时段将被删除
ON COMMIT PRESERVE ROWS  -----会话结束时临时表被删除

临时表空间
dba_tablespace_groups --查询的数据字典
创建临时表空间
默认使用的临时表空间 temp 
create temporary tablespace tmp_name tempfile 'path_name/file_name' size 5m group group_name; 
alter user weideguo temporary tablespace [group_name | tmp_name]   --给用户指定临时表空间
alter database <database_name> default tempoprary tablespace [group_name | tmp_name]  ---数据库级设置临时表空间

临时表空间组
alter tablespace temp1 tablespace group tempgrp;
alter database default temporary tablespace tempgrp;


transportable data encrypt(透明数据加密)
加密表空间  
需要使用wallet
在sqlnet.ora设置wallet
1. ENCRYPTION_WALLET_LOCATION =  
   (SOURCE=  
	 (METHOD=file)  
	 (METHOD_DATA=  
	   (DIRECTORY=/u01/app/oracle/product/11.2.0/wallet))) 
2. 在wallet中创建key
alter system set encryption key authenticated by "password";
alter system set key identified by "password";   ---使用两者之一
alter system set wallet close identified by "password";  ---关闭wallet; open 则为启用

使用wallet登录
mkstore -wrl /u01/app/oracle/product/11.2.0/wallet -create   ---创建wallet   wallet的密码跟oracle密码没有联系
---如上修改sqlnet.ora文件
mkstore -wrl /u01/app/oracle/product/11.2.0/wallet -createCredential orcl oracle_user oracle_user_password    ---需要输入在交互中输入wallet密码
sqlplus /@orcl   ---登录

支持的加密算法
3DES168 AES128  AES192  AES256

创建加密表字段
 create table tde_private(  
id number(10) [primary key],  
info varchar2(50) encrypt using 'AES192'  
); 
创建加密表空间
create tablespace encrypted_ts encryption [using 'AES256'] default storage(encrypt);

CREATE TABLE sf_tab ( 
id NUMBER, 
clob_data CLOB 
) 
LOB(clob_data) STORE AS SECUREFILE;

securefiles   ----加密、利用压缩节约空间和数据重复消除
			  ----默认的LOB存储格式为BASIXFILE
【db_securefile】系统参数 ----为ignore是强制使用basicfile;为permitted允许使用securefile

oracle ACL
(access control)
---数据字典 dba_network_acls	dba_network_acl_privileges
BEGIN DBMS_NETWORK_ACL_ADMIN.CREATE_ACL ( 
acl =>'mycompany-com-permissions.xml', principal => 'ACCT_MGR', 
is_grant => TRUE, privilege => 'connect');
DBMS_NETWORK_ACL_ADMIN.ASSIGN_ACL ( 
acl => 'mycompany-com-permissions.xml', 
host =>'*.mycompany.com');
END;

COMPRESS
create tablespace TEST datafile '/u01/oracle/ora11g/oradata/test/test.dbf' size 10M default compress;   ----创建压缩表空间
alter tablespace test default compress;   ----压缩表；nocompress为不压缩

xml表
create table xmltable of xmltype;
insert into xmltable values(xmltype(getclobdocument('EXP_DIR','order.xml')));    ---function getclobdocument需要自己编写 
查询xml
SELECT extractValue(value(X),'/PurchaseOrder/Reference') FROM XMLTABLE X;     --- extract(),extractValue(),和existsNode()
select * from xmltable;



resumable space  ---遇到空间不足，事务不会直接中断，而是生成alert log，解决后事务自动恢复。
【resumable_timeout】设置为非0,即启用   在该时间内解决后自动恢复

VIEW
create view  ... with check option;   ----由视图插入时检查是否符合视图的约束
					 
inline view  --内联视图
select * from (select * from abc);    ---(select * from abc)即为内联视图

drop view view_name;

物化视图
materialized view
materilized view log    ---用于支持快速刷新
物化视图本身会存储数据
DBMS_MVIEW.REFRESH  ----手动刷新
----创建语句
create materialized view view_name
refresh [fast|complete|force]
[on [commit|demand] | start with (start_time) next (next_time)]
as
{创建物化视图用的查询语句}   ----如 select语句

snapshot(表的快照)
dba_hist_wr_control   ---快照时间隔及保留时间查询
dba_hist_snapshot     ---查询历史快照

create snapshot log on table_name;   ---建立表的快照日志
---创建表的快照
---COMPLETE 全表更新；FAST  增量更新
---使用【materialized view】代替【SNAPSHOT】可以实现不同表的数据的同步，物化视图和快照都可以直接查看。两者相同？
CREATE SNAPSHOT snapshot_name  
REFRESH {COMPLETE|FAST} START WITH SYSDATE NEXT SYSDATE+1/24
as select * from table_name@dblink_name;
EXEC DBMS_SNAPSHOT.REFRESH('snapshot_name','C');   ---手动刷新快照。后面为刷新的方式：C--complete;F--fast。


constraint 
---完整性约束
---约束类型
check      		C
foreign key		R
primary key		P
unique			U				 

---创建表时添加约束
constraint c_name primary key (col_name);  --设置主键
constraint c_name foreign key (col_name) references outside_table_name(ouside_table_col);  --设置外键，参照的键必须唯一
constraint c_name unique(col_name);

alter table table_name add constraint constraint_name unique (column_name) [deferrable initially deferred];    ---【deferrable】指定约束可以推迟；【not deferrable】为不可推迟。【initially deferrable】启动推迟，在提交事务时才使用约束判断DML是够合法；【initially immediate】不启用延迟，执行sql语气即使用约束检查。
alter table table_name add constraint constraint_name check(column>100) deferrable;   --只能在添加约束时设置constriant可延迟
alter table table_name drop constraint constraint_name;   ---删除约束


约束constraint三个属性：
deferrable  ---可延迟的
not deferrable  ---不可延迟的

只有在可延迟状态才可以设置延迟
set constraint constraint_name deferred;    ---设置约束延迟，即在事务提交时再判断约束
set constraint constraint_name immediate;   ---恢复约束在执行sql语句时生效

alter table table_name disable constraint constraint_name;    ---禁用约束
alter table table_name enable constraint constraint_name;	  ---启用约束
alter table table_name enable novalidate constraint constraint_name;   ---对已有的数据不验证约束，新添加的验证约束。

ENABLE VALIDATE      ---检查新、旧数据
ENABLE NOVALIDATE    ---检查新插入，不检查已有数据
DISABLE VALIDATE     ---不检查新插入，不允许对旧数据进行修改
DISABLE NOVALIDATE   ---新、旧数据都不检查


INDEX
unique index     ---添加【unique】或【primary key】约束后自动创建
nonunique index  ---手动创建

---使用truncate  index将失效，需要rebulid

--索引数据字典
dba_indexes
user_indexes

create index index_name on table_name (column_name);
create index index_name on table_name (column_name1,column_name2);
create index index_name on table_name (column_name desc);

alter index index_name invisible;    --索引不可见，但索引依然更新
alter index index_name visible;

alter index index_name unusable;    ----设置索引不可用，重新启用需要重建
alter index index_name rebuild; 

alter index index_name rebuiled online;   ----生产环境不建议使用
alter index index_name rebuild [tablespace tablespace_name] -----加入表空间名，会将指定的索引移动到指定的表空间当中

create index index_name on ....;   			---创建B树索引
create bitmap index index_name on ...;      ---创建位图索引

局部索引 local index
dba_ind_partitions

全局索引 global index


SYNONYM
create [public] synonym synonym_name for table_name;    ----为表创建同义词
drop [public] synonym synonym_name;   ----删除同义词
oracle的内部视图为V_$VIEWNAME，其synonyms为V$VIEWNAME。只能对视图或表授予权限



SEQUENCE
create sequence sequence_name 
start with 1
increment by 1
minvalue 1 maxvalue 100;


--包（package）可以包含存储过程（procedure）、函数（function）、触发器（trigger）
alter trigger trigger_name enable 				--激活触发器，禁用为disable
alter table table_name enable all triggers 		--激活所有触发器

查看源代码（proceduce、function、trigger、package）的数据字典
DBA_SOURCE
user_source



rowid 格式
AAAPec+AAF+AAAABS+AAA
Data object number+relative file number+block number+row number

ROWNUM	

	
绑定变量
【&】指定变量   
【&&】指定变量时只需要输入一次，除非使用【undefine fieldname】解除					 
如
select &sal s from dual;    ---每次运行都有交互提示输入sal的值
select &&sal s from dual;	---第一次运行时有交互提示输入sal的值，之后直接使用该值而不会再有提示。使用【undefined sal】可以解绑定


锁

【commit】或【rollback】解锁
TX锁称为事务锁或行级锁。
TM锁称为表级锁。
	SS(Row-S)
	SX(Row-X)
	S(share)
	SSX(share row exclusive)
	X(exclusive) 
TM锁获得后，系统再自动申请TX类型的锁，并将实际锁定的数据行的锁标志位进行置位。

v$locked_object;   ---锁的信息记录视图
v$lock

insert、update、delete 加行级排他锁
drop、truncate、alter  加表级排他锁

SELECT ... FOR UPDATE [OF column_list][WAIT n|NOWAIT][SKIP LOCKED];    ---行级锁。排他锁？。【commit】解除锁定
---如不使用of指定锁定的表的列，则所有表的相关行均被锁定;若在of中指定了需修改的列，则只有与这些列相关的表的行才会被锁定。
---wait 等待多少秒后报资源忙的错误;
---skip locked  跳过已经被锁住的行，只执行能够获得锁的行。即不报资源忙错误。
             
lock table table_name in {share|exclusive} mode;   ---加锁

如果不能row exclusive的话，就不能进行insert,update,delete 操作
不能获得exclusive锁定就不能进行drop操作
share  ---共享锁   允许其他session同时给对象加share锁    
exclusive  ---排他锁   不允许其他session同时给对象加锁
row share  ----行共享锁  不允许其他SESSION执行exclusive锁定
row exclusive    ---行排他锁  只允许其他session加row share、row exclusive锁。
share row exclusive    ---共享行排他锁  只允许其他session个对象加row share锁 


数据库 
oracle11g在启动时非集群只能一个实例(instance)对应一个数据库(database)
创建数据库
使用dbca图形界面创建
使用sql语句创建： create database ...

删除数据库
alter system enable restricted session;   ---切换数据库的系统状态




oracle queue
DBMS_AQADM.CREATE_QUEUE
user_queue_tables
user_queues
user_queue_subscribers
user_queue_schedules




闪回
---依据表空间的内容闪回，如删除时只是逻辑删除
---由undo表空间的大小确定flashback query能力的大小

flash recovery area 
----闪回恢复区,具体对应操作系统中的一个目录
v$flash_recovery_area_usage   ----闪回恢复区各项的使用率
v$recovery_area_usage    	  -----11g中使用以代替v$flash_recovery_area_usage
【db_recovery_file_dest_size】指定闪回恢复区的可用空间大小，设置为空即取消闪回恢复区 -----设置了闪回恢复区，则【log_archive_dest】不能设置
【db_recovery_file_dest】指定闪回恢复区的位置
【db_flashback_retention_target】指定数据库可以回退的时间，单位为分钟

V$CONTROLFILE, V$LOGFILE, V$ARCHIVED_LOG, V$DATAFILE_COPYIS_RECOVERY_DEST_FILE ,指明相关的文件是否在恢复区内


查看是否处于闪回状态 
select flashback_on from v$database;

开启闪回 --mount模式
	1. alter database archivelog;
	2.alter database flashback open;   ---必须处于归档模式； off

闪回查询
	SELECT column_name FROM table_name [AS OF SCN|TIMESTAMP expression] [WHERE expression] ;

	闪回表  必须先启用行移动(row movement)
	alter table table_name enable row movement;  --禁用为disable
	FLASHBACK TABLE table_name TO SCN|TIMESTAMP expression;

flashback 技术是以Undo segment中的内容为基础的，因此受限于UNDO_RETENTON参数。
把整个数据库回退到过去的某个时点的状态，这个功能依赖于Flashback log 日志。
DB_FLASHBACK_RETENTION_TARGET    ----flashback log保留的时间，flashback database能恢复的最早时间点
db_recovery_file_dest            ----flashback log的保留位置
ora_rowscn  --oracle的伪列

to_date('2016-03-11 10:00:00','yyyy-mm-dd hh24:mi:ss')   --将时间转换成timestamp的格式
select current_scn from v$database;  --查询当前scn
select timestamp_to_scn(sysdate) from dual;  ---查询当前scn
scn_to_timestamp、timestamp_to_scn   ---timestamp与scn的转换


闪回事务 --查询变更sql
权限
select any transaction
execute on dbms_flashback
补全日志
alter database add supplemental log data(primary key,unique index) columns;  --drop为关闭补全日志 
select supplemental_log_data_min from v$database;  --查看是否启用补全日志

select xid,operation,commit_scn,undo_sql from flashback_transaction_query where xid in (select versions_xid from table_name versions between scn minvalue and maxvalue);   ---查询特定scn内的事务

select versions_starttime,versions_endtime,versions_xid,versions_operation,t.* from table_name versions between scn minvalue and maxvalue t;    ----查询表的事务

DBMS_FLASHBACK.TRANSACTION_BACKOUT    ---闪回事务使用的procedure

declare
v_xid SYS.XID_ARRAY:=SYS.XID_ARRAY(hextoraw('000A002000016CD0'));    -----使用VERSIONS_XID获取v_xid
begin
SYS.DBMS_FLASHBACK.TRANSACTION_BACKOUT(numtxns=>1,xids=>v_xid,options=>dbms_flashback.NOCASCADE_FORCE);
end;

----NOCASCADE：若检测到Transaction之间存在依赖关系，则无法进行回退
----NOCASCADE_FORCE：若Transaction间仅存在” Write-after-write dependency”类型的依赖关系，则可以实施强行回退；若遇到除” Write-after-write dependency”以外的其它类型的依赖关系，则无法进行回退
----CASCADE：对存在依赖关系的Transaction实施连带回退
----NONCONFLICT_ONLY：仅回退Transaction里不存在依赖关系的SQL，会破坏事务的原子性

闪回版本的伪列
VERSIONS_STARTTIME	返回查询结果行的第一个版本的时间戳。
VERSIONS_STARTSCN	返回查询结果行的第一个版本的SCN。
VERSIONS_ENDTIME	返回查询结果行的最后一个版本的时间戳。
VERSIONS_ENDSCN		返回查询结果行的最后一个版本的SCN。
VERSION_XID			对于每一行的每一个版本，返回创建该版本的事务的ID（一个RAW类型数字）。
VERSIONS_OPERATION	对于每一行的每一个版本，返回代表生成该版本的操作的一个字符。返回值分别为I（插入操作）、U（更新）或者D（删除）。

select * from scott.emp versions between scn minvalue and maxvalue [as of scn snc_num];  ----在某个scn时查询版本信息

select versions_xid as vxid,versions_startscn,versions_endscn,versions_operation 
from weideguo.emp versions  
between scn minvalue and maxvalue as of scn 2515913 where empno=8000;    ---在某个scn查询某一行的变化情况


闪回删除  --只支持非sys用户
【recyclebin】参数为on时才启用回收站
select * from recyclebin;   --查看回收站的对象，使用数据字典recyclebin、user_recyclebin、dba_recyclebin
flashback table t1 to before drop  [rename to t2];   --闪回删除,可以同时选择更改表名
purge table table_name;    --清空回收站 --可为table、index、recyclebin、dba_recyclebin、tablespace、user
drop table table_name purge;  --同时在回收站清空


create database link dblink_name connect to user_name identified by user__password usering 'connect_identifier';  --创建database liink，connect_identifier由$oracle_home/network/admin/tnsnames.ora下设置
select * from table_name@dblink_name;  ---使用dblink

闪回数据库   --在mount模式  
--表被使用purge参数从回收站删除后不能使用闪回删除恢复，可以使用闪回数据库恢复  
FLASHBACK DATABASE [database_name] to [SCN|TIMESTAMP expression]|[BEFORE SCN|TIMESTAMP expression]
alter database open resetlogs;  --需要重置undo日志 或者在只读模式 read only

【v$flashback_database_log】由视图估算可闪回的点

Flashback Database(依赖于闪回日志)之外，其他的闪回技术都是依赖于Undo撤销数据(undo表空间)

FDA(flashback data archive   )
---闪回数据归档
CREATE FLASHBACK ARCHIVE [default] fbar1 TABLESPACE "TBS_DATA1" RETENTION 2 DAY;   --创建闪回数据归档区。可以有一个默认闪回数据归档区
alter table table_name flashback archive fbar1;  ---如果不指定flashback archive名使用默认。
alter flashback archive flar1 purge all;   ---清空闪回数据归档
--数据字典 *为dba或user
*_FLASHBACK_ARCHIVE
*_FLASHBACK_ARCHIVE_TS
*_FLASHBACK_ARCHIVE_TABLES
--权限
flashback archive administrator
flashback archive on fbar1 

闪回数据归档区是一个逻辑概念，是从一个或者多个表空间中拿出一定的空间，来保存表的修改历史，这样就摆脱了对Undo撤销数据的依赖，不利用undo就可以闪回到归档策略内的任何一个时间点

还原点  --restore point
----闪回数据库是可以使用还原点
create restore point point_name;  ---创建还原点
drop database;   ---删除数据库

	
RAC
Real Apply Cluster
oralce集群架构
RAC是实现grid的一种方案

GI
(Grid Infrastructure ) 
GI主要包括了两个主要部分，即clusterware和ASM(Automatic Storage Management)

	
DSG 
基于日志抽取实现的备份工具

ADG
(Active Data Guard)  
用于主、备库备份，通过数据在线日志后归档日志解析

DG
(Dataguard)是oracle公司的主备，用于主库宕机时，应用切换到备库
物理standby   ---主备库完全一样，直接应用redo实现同步
逻辑standby   ---物理组织和数据结构可以不一样，将redo日志转换成SQL，在standby执行SQL实现同步

OGG
(oracle golden guard)
一种基于日志的结构化数据复制备份软件，它通过解析源数据库在线日志或归档日志获得数据的增量变化，再将这些变化应用到目标数据库，从而实现源数据库与目标数据库同步

OCR 
(Oracle Cluster Registry)   
基于分布式高速缓存共享架构  

gateway 
透明网关  Transparent Gateway
oracle对其他类型数据库的访问
实现异构服务的技术（不同数据库平台的互连称为数据库的异构服务）	
	
	
修改数据时区
ALTER DATABASE SET TIME_ZONE='+08:00';
ALTER SESSION SET TIME_ZONE='+08:00';	

语言设置
nls_session_parameters  ---数据字典
nls_database_parameters

NLS_LANG是环境变量，NLS_LANG=<Language>_<Territory>.<Clients Characterset>
----NLS( National Language Support)
NLS_LANGUAGE主要控制SESSION中提示消息的语言，可以使用ALTER SESSION在SQLPLUS里面设置；
NLS_TERRITORY主要控制SESSION中的日期和货币等本地化参数的现实格式，也可以像NLS_LANGUAGE一样在 SESSION 里面设置；
NLS_CHARACTERSET控制客户端的字符集，不能在SESSION里面进行设置，只能通过NLS_LANG环境变量的方式进行设置。

NLS_SORT和NLS_COMP参数控制着字符比较和排序的行为
NLS_SORT={ BINARY | linguistic_definition}
NLS_COMP={ BINARY | LINGUISTIC | ANSI }

