show index from table_name [from database_name] 

SELECT * FROM t1, t2 FORCE INDEX (index_for_column) WHERE t1.col_name=t2.col_name;  --强制使用指定索引


SELECT * FROM t1, t2 IGNORE INDEX (index_for_column) where ...                      ---强制不使用某个索引




count(*)/count(1)  --没有where子句时，使用最小的索引进行查询；带有where子句，使用能优化where的索引。	


count(*)包括了所有列，相当于行数，在统计结果的时候， 不会忽略列值为NULL 
count(1)包括了所有列，用1代表代码行，在统计结果的时候， 不会忽略列值为NULL （不一定为1，可以是任意常量）
count(column)只包括列名那一列，在统计结果的时候，会忽略列值为空（null）的计数， 即某个字段值为NULL时，不统计。

https://dev.mysql.com/doc/refman/8.0/en/aggregate-functions.html#function_count
InnoDB handles SELECT COUNT(*) and SELECT COUNT(1) operations in the same way. There is no performance difference.
MyISAM tables, COUNT(*) is optimized to return very quickly if the SELECT retrieves from one table
, an exact row count is stored for this storage engine and can be accessed very quickly. 
COUNT(1) is only subject to the same optimization if the first column is defined as NOT NULL.


索引
fulltext索引   ----只有myisam使用
CREATE TABLE fulltext_sample(name TEXT,FULLTEXT(name)) ENGINE=MyISAM;
ALTER TABLE fulltext_sample ADD FULLTEXT(name);   ----改表结构添加全文索引
create fulltext index index_name on fulltext_sample(name);   


alter table table_name add key (col1,col2);
alter table table_name add unique key (col1,col2);
alter table table_name add key key_name (col1,col2);


alter table table_name drop index index_name;

show index from table_name;

show keys from table_name;

前缀索引
alter table table_name add key(column_name(prefix_length))
create index index_name on table_name(column_name(prefix_length))
	
create index index_name USING {BTREE | HASH} on tbl_name (index_col_name,...) ...

b+树索引
	 用于=, >, >=, <, <=, or BETWEEN
	 LIKE比较不能以通配符开始
	 IS NULL可以使用索引
	 Any index that does not span all AND levels in the WHERE clause is not used to optimize the query. In other words, to be able to use an index, a prefix of the index must be used in every AND group.

	 最左原则
	 if you have a three-column index on (col1, col2, col3), you have indexed search capabilities on (col1), (col1, col2), and (col1, col2, col3). 
	 
hash索引
	只能用于= or <=> ,返回单条记录
	不能用于加快ORDER BY
	Only whole keys can be used to search for a row
    


随机读取 如无法使用索引时的全表扫描
顺序读取 数据块的读取需要满足一定的顺序，如根据索引信息读取数据

mysql定位过程：
打开索引->根据索引键值逐层找B+树branch节点->定位到叶子节点，将cursor定位到满足条件的rec上


adaptive hash index(自适应哈希索引)
	engine取数据后，将cursor的位置保存起来，取下一条数据时，先恢复cursor的位置，成功则直接取数，不成功则重新定位cursor的位置。存储于hash_table的内存中，位于buffer pool。
	the hash index is always built based on an existing B-tree index on the table. 
	innodb_adaptive_hash_index={on|off}  --默认启用

	大量多表jion、模糊查询不建议使用AHI





null值对索引的影响
where column_name is not null  --不走索引




排序
指定主键时，不加order by语句则按照主键排序
不指定主键，但unqiue键在为第一个字段，按unique键排序。
不指定主键，按照插入顺序排序。	

